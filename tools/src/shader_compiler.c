#include <stdio.h>
#include <string.h>
#include <windows.h>
#include "common.h"

b32 upFolder(char* path) {
    u32 len = strlen(path);
    for(u32 i = len - 1; i > 0; i--) {
        if(path[i] == '\\' || path[i] == '/') {
            path[i] = '\0';
            return TRUE;
        }
    }
    return FALSE;
}

b32 isSpv(const char* name) {
    u32 len = strlen(name);
    return strstr(name, ".spv") != NULL;
}

void capsilize(const char* name, char* caps) {
    char c;
_loop:
    c = *name;
    if(c == '\0' || c == '.') goto _end;
    if(c < 123 && c > 96) {
        c -= 32;
    }
    *caps = c;
    *caps++;
    *name++;
goto _loop;
_end:
    *caps = '\0';
}

typedef struct {
    const char* path;
    const char* name;
    FILE* resource;
    FILE* header;
    void* read_buffer;
    u64 buffer_size;
} SpvProcessingInfo;

b32 processSpvFile(const SpvProcessingInfo* info, u64* iterator) {
    FILE* src = fopen(info->path, "r");
    if(!src) {
        printf("failed to open source: %s\n", info->path);
        return FALSE;
    }

    char caps_name[256];
    capsilize(info->name, caps_name);

    fseek(src, 0, SEEK_END);
    u64 src_size = ftell(src);
    fseek(src, 0, SEEK_SET);
    for(u32 i = 0; i < src_size; i += info->buffer_size) {
        u64 cpy_size = fread(info->read_buffer, sizeof(u32), info->buffer_size / sizeof(u32), src);
        fwrite(info->read_buffer, sizeof(u32), cpy_size / sizeof(u32), info->resource);
    }
    fprintf(info->header, "#define SHADER_LOC_%s %luLU\n", caps_name, *iterator);
    fprintf(info->header, "#define SHADER_SIZE_%s %luLU\n", caps_name, src_size);
    *iterator += src_size;

    fclose(src);
    return TRUE;
}                                              

int main(int argc, char** argv) {
    if(argc != 4) {
        printf("incorrect number of arguments, should be: \".\\shader_compiler.exe <resource directory> <resource file> <header file>\"\n");
        return 1;
    }

    FILE* resource = fopen(argv[2], "w+");
    FILE* header = fopen(argv[3], "w+");
    u64 read_buffer_size = 4*1024*1024;
    char* read_buffer = malloc(read_buffer_size);

    if(!resource || !header) {
        printf("failed to open files: %s, %s\n", argv[2], argv[3]);
        return 2;
    }

    fprintf(header, "\n//WARNING: THIS FILE IS AUTOMATICALLY GENERATED FROM shader_compiler.exe!\n\n#ifndef _SHADERS_INCLUDED\n#define _SHADERS_INCLUDED\n\n");

    char directory[256];
    char directory_search[256];
    char file_path[256];
    strcpy(directory, argv[1]);
    strcat(directory, "\\");
    strcpy(directory_search, argv[1]);
    strcat(directory_search, "\\*");

    WIN32_FIND_DATA find_data;
    HANDLE find_handle;
    u32 files_processed = 0;

    SpvProcessingInfo spv_processing_info = (SpvProcessingInfo) {
        .read_buffer = read_buffer,
        .buffer_size = read_buffer_size,
        .resource = resource,
        .header = header
    };
    u64 iterator = 0;

    find_handle = FindFirstFile(directory_search, &find_data);
    if(find_handle == INVALID_HANDLE_VALUE) goto _end;
    if(isSpv(find_data.cFileName)) {
        strcpy(file_path, directory);
        strcat(file_path, find_data.cFileName);
        spv_processing_info.path = file_path;
        spv_processing_info.name = find_data.cFileName;

        processSpvFile(&spv_processing_info, &iterator);
        files_processed++;
    }
_loop:
    if(!FindNextFile(find_handle, &find_data)) goto _end;
    if(isSpv(find_data.cFileName)) {
        strcpy(file_path, directory);
        strcat(file_path, find_data.cFileName);
        spv_processing_info.path = file_path;
        spv_processing_info.name = find_data.cFileName;

        processSpvFile(&spv_processing_info, &iterator);
        files_processed++;
    }
    goto _loop;
_end:
    fprintf(header, "\n#endif\n\n");

    free(read_buffer);
    fclose(resource);
    fclose(header);
    printf("files processed: %u, bytes processed: %lu\n", files_processed, iterator);
    return 0;
}
