#include <stdio.h>
#include <string.h>
#include <windows.h>
#include "common.h"

b32 upFolder(char* path) {
    u32 len = strlen(path);
    for(u32 i = len - 1; i > 0; i--) {
        if(path[i] == '\\' || path[i] == '/') {
            path[i] = '\0';
            return TRUE;
        }
    }
    return FALSE;
}

b32 isSpv(const char* name) {
    return strstr(name, ".spv") != NULL;
}

void capsilize(const char* name, char* caps) {
    char c;
_loop:
    c = *name;
    if(c == '\0' || c == '.') goto _end;
    if(c < 123 && c > 96) {
        c -= 32;
    }
    *caps = c;
    caps++;
    name++;
goto _loop;
_end:
    *caps = '\0';
}

typedef struct {
    const char* path;
    const char* name;
    FILE* resource;
    FILE* header;
    void* read_buffer;
    u64 buffer_size;
} SpvProcessingInfo;

typedef struct {
    const char* flag;
    const char* entry;
    const char* next;
} StageInfo;

const StageInfo c_stage_infos[] = {
    (StageInfo) {
        .flag = "VK_SHADER_STAGE_VERTEX_BIT",
        .entry = "SHADER_ENTRY_VERTEX",
        .next = "VK_SHADER_STAGE_FRAGMENT_BIT"
    },
    (StageInfo) {
        .flag = "VK_SHADER_STAGE_FRAGMENT_BIT",
        .entry = "SHADER_ENTRY_FRAGMENT",
        .next = "0"
    },
    (StageInfo) {
        .flag = "VK_SHADER_STAGE_COMPUTE_BIT",
        .entry = "SHADER_ENTRY_COMPUTE",
        .next = "0"
    }
};

typedef struct {
    char name[256];
} ShaderInfo;

char getShaderType(const char* name) {
    u32 str_len = strlen(name);
    return name[str_len - 1];
}

b32 processSpvFile(const SpvProcessingInfo* info, u64* iterator, char* caps_name) {
    FILE* src = fopen(info->path, "rb");
    if(!src) {
        printf("failed to open source: %s\n", info->path);
        return FALSE;
    }

    capsilize(info->name, caps_name);

    fseek(src, 0, SEEK_END);
    u64 src_size = ftell(src);
    for(u32 i = 0; i < src_size; i += info->buffer_size) {
        fseek(src, i, SEEK_SET);
        u64 cpy_size = fread(info->read_buffer, 1, info->buffer_size, src);
        fwrite(info->read_buffer, 1, cpy_size, info->resource);
    }

    StageInfo stage_info;
    switch (getShaderType(caps_name)) {
        case 'V':
            stage_info = c_stage_infos[0];
            break;
        case 'F':
            stage_info = c_stage_infos[1];
            break;
        case 'C':
            stage_info = c_stage_infos[2];
            break;
        default:
            stage_info = c_stage_infos[0];
    }

    fprintf(info->header, 
        "\t(ShaderInfo) {\n" 
        "\t\t.stage = %s,\n"
        "\t\t.code_offset = %lu,\n"
        "\t\t.code_size = %lu,\n"
        "\t},\n",
        stage_info.flag, *iterator, src_size
    );
    *iterator += src_size;

    fclose(src);
    return TRUE;
}                                              

int main(int argc, char** argv) {
    if(argc != 4) {
        printf("incorrect number of arguments, should be: \".\\shader_compiler.exe <resource directory> <resource file> <header file>\"\n");
        return 1;
    }

    FILE* resource = fopen(argv[2], "wb");
    FILE* header = fopen(argv[3], "w");
    u64 read_buffer_size = 4*1024*1024;
    char* read_buffer = malloc(read_buffer_size);

    if(!resource || !header) {
        printf("failed to open files: %s, %s\n", argv[2], argv[3]);
        return 2;
    }

    fprintf(header, 
        "\n//WARNING: THIS FILE IS AUTOMATICALLY GENERATED FROM %s\n\n"
        "#ifndef _SHADERS_INCLUDED\n"
        "#define _SHADERS_INCLUDED\n\n",
        argv[0]
    );

    char directory[256];
    char directory_search[256];
    char file_path[256];
    strcpy(directory, argv[1]);
    strcat(directory, "\\");
    strcpy(directory_search, argv[1]);
    strcat(directory_search, "\\*");

    WIN32_FIND_DATA find_data;
    HANDLE find_handle;
    u32 files_processed = 0;

    SpvProcessingInfo spv_processing_info = (SpvProcessingInfo) {
        .read_buffer = read_buffer,
        .buffer_size = read_buffer_size,
        .resource = resource,
        .header = header
    };
    u64 iterator = 0;
    ShaderInfo* shader_infos = malloc(1024 * sizeof(ShaderInfo)); 


    fprintf(header,
        "typedef struct {\n"
        "\tu64 code_offset;\n"
        "\tu64 code_size;\n"
        "\tu32 stage;\n"
        "} ShaderInfo;\n\n"
        "#define SHADER_ENTRY_VERTEX \"vertexFunc\"\n"
        "#define SHADER_ENTRY_FRAGMENT \"fragmentFunc\"\n"
        "#define SHADER_ENTRY_COMPUTE \"computeFunc\"\n\n"
        "const ShaderInfo c_shader_infos[] = {\n"
    );

    find_handle = FindFirstFile(directory_search, &find_data);
    if(find_handle == INVALID_HANDLE_VALUE) goto _end;
    if(isSpv(find_data.cFileName)) {
        strcpy(file_path, directory);
        strcat(file_path, find_data.cFileName);
        spv_processing_info.path = file_path;
        spv_processing_info.name = find_data.cFileName;

        processSpvFile(&spv_processing_info, &iterator, shader_infos[files_processed].name);
        files_processed++;
    }
_loop:
    if(!FindNextFile(find_handle, &find_data)) goto _end;
    if(isSpv(find_data.cFileName)) {
        strcpy(file_path, directory);
        strcat(file_path, find_data.cFileName);
        spv_processing_info.path = file_path;
        spv_processing_info.name = find_data.cFileName;

        processSpvFile(&spv_processing_info, &iterator, shader_infos[files_processed].name);
        files_processed++;
    }
    goto _loop;
_end:
    fprintf(header, "};\n\n");
    for(u32 i = 0 ; i < files_processed; i++) {
        fprintf(header, "#define SHADER_ID_%s %u\n", shader_infos[i].name, i);
    }
    fprintf(header, 
        "#define SHADER_COUNT %u\n"
        "#define SHADER_BUFFER_SIZE %luLU\n\n#endif\n\n", 
        files_processed, iterator
    );

    free(read_buffer);
    fclose(resource);
    fclose(header);
    printf("files processed: %u, bytes processed: %lu\n", files_processed, iterator);
    return 0;
}
